%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: a5f4aa9eb446434284de310f7302c48e, type: 3}
  m_Name: RaymarcherUnlitTemplate
  m_EditorClassIdentifier: 
  hlslTemplate: "Shader \"SDF/Domain\"\n{\n    // PROP BLOCK\n    Properties\n   
    {\n        [Header(Shader properties)]\n        [Enum(UnityEngine.Rendering.CullMode)]
    _Cull (\"Cull\", Int) = 0\n        [KeywordEnum(Less, LEqual, Equal, GEqual,
    Greater, NotEqual, Always)] _ZTest(\"ZTest\", Int) = 0\n\n        [Header(Raymarcher)]\n       
    _MAX_STEPS (\"max raymarching steps\", Int) = 200\n        _MAX_DISTANCE (\"marx
    raymarching distance\", Float) = 200.0\n        _RAY_ORIGIN_BIAS (\"ray origin
    bias\", Float) = 0\n        _EPSILON_RAY (\"epsilon step for ray to consider
    hit\", Float) = 0.001\n        _EPSILON_NORMAL (\"epsilon for calculating normal\",
    Float) = 0.001\n\n        [KeywordEnum(Near, Face)] _RayOrigin(\"Ray origin\",
    Int) = 0\n        [KeywordEnum(World, Local)] _Origin(\"Scene origin\", Int)
    = 0\n        [Tooltip(Only works for origin type local)]\n        [Toggle] _PRESERVE_SCALE
    (\"Preserve local scale\", Int) = 1\n\n        [Header(SDF Scene)]\n        {{
    PROPERTIES_SHADERLAB }}\n    }\n\n    //    Fallback \"Diffuse\"\n\n    SubShader\n   
    {\n        Tags\n        {\n            \"RenderType\"=\"Geometry\"\n           
    \"Queue\"=\"Geometry+1\" // +1 to resolve artifacts when using Cull Off\n           
    \"IgnoreProjector\"=\"True\"\n        }\n        //        Blend SrcAlpha OneMinusSrcAlpha\n       
    ZTest [_ZTest] // Can be customized manually, but when meshes intersect SDFs,
    this helps to draw both properly  \n        Cull [_Cull] // Draw camera inside
    a domain\n        ZWrite [_ZWrite]\n\n        // common includes for all passes\n       
    HLSLINCLUDE\n\n        #pragma target 5.0\n        #pragma vertex vert\n       
    #pragma fragment frag\n        #pragma shader_feature_local _ORIGIN_WORLD _ORIGIN_LOCAL\n       
    #pragma shader_feature_local _RAYORIGIN_NEAR _RAYORIGIN_FACE\n        #pragma
    shader_feature_local _DRAWMODE_MATERIAL _DRAWMODE_ALBEDO _DRAWMODE_TEXTURE _DRAWMODE_NORMALLOCAL
    \\\n            _DRAWMODE_NORMALWORLD _DRAWMODE_ID _DRAWMODE_STEPS _DRAWMODE_DEPTH\n       
    #pragma shader_feature_local _SCALE_INVARIANT\n        #pragma shader_feature_local
    _ZWRITE_ON _ZWRITE_OFF\n        // #pragma shader_feature_local _SCENEVIEW\n\n       
    #include \"UnityCG.cginc\"\n        #include \"Assets/SDF/Includes/primitives.cginc\"\n       
    #include \"Assets/SDF/Includes/operators.cginc\"\n        #include \"Assets/SDF/Includes/noise.cginc\"\n       
    #include \"Assets/SDF/Includes/types.cginc\"\n        #include \"Assets/SDF/Includes/util.cginc\"\n       
    #include \"Assets/SDF/Includes/matrix.cginc\" // FIXME: inverse might be a problem\n\n       
    #pragma shader_feature_local _PRESERVE_SCALE_ON\n        static const float4x4
    SCALE_MATRIX =\n            #if defined(_PRESERVE_SCALE_ON) && defined(_ORIGIN_LOCAL)\n           
    {\n                {length(float3(UNITY_MATRIX_M[0].x, UNITY_MATRIX_M[1].x, UNITY_MATRIX_M[2].x)),
    0, 0, 0},\n                {0, length(float3(UNITY_MATRIX_M[0].y, UNITY_MATRIX_M[1].y,
    UNITY_MATRIX_M[2].y)), 0, 0},\n                {0, 0, length(float3(UNITY_MATRIX_M[0].z,
    UNITY_MATRIX_M[1].z, UNITY_MATRIX_M[2].z)), 0},\n                {0, 0, 0, 1}\n           
    };\n            #else\n            MATRIX_ID;\n        #endif\n\n        static
    const float4x4 SCALE_MATRIX_I = inverse(SCALE_MATRIX);\n        \n        //
    https://gist.github.com/unitycoder/c5847a82343a8e721035\n        // static const
    float3 camera_forward = UNITY_MATRIX_IT_MV[2].xyz;\n        static const float4x4
    inv = mul(SCALE_MATRIX, inverse(\n                                           
    #ifdef _ORIGIN_WORLD\n                                            UNITY_MATRIX_VP\n                                           
    #else\n                                            UNITY_MATRIX_MVP\n                                           
    #endif\n                                        ));\n\n        UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n\n       
    float _EPSILON_RAY;\n        float _EPSILON_NORMAL;\n        float _MAX_DISTANCE;\n       
    float _RAY_ORIGIN_BIAS;\n        float _MAX_STEPS;\n\n        {{ PROPERTIES_HLSL
    }}\n\n        ENDHLSL\n\n        Pass\n        {\n            HLSLPROGRAM\n           
    v2f vert(appdata_base v)\n            {\n                v2f o;\n               
    o.vertex = UnityObjectToClipPos(v.vertex); // clip space\n                o.screenPos
    = ComputeScreenPos(o.vertex); // from 0,0 to 1,1\n                o.hitpos =
    v.vertex;\n                COMPUTE_EYEDEPTH(o.screenPos.z);\n               
    return o;\n            }\n\n            // =======================================================================\n           
    Hit __SDF(float3 p)\n            {\n                {{ SDF }}\n            }\n\n           
    // TODO: lighting\n            fixed4 __MATERIAL(int id)\n            {\n               
    static fixed4 _ALBEDO[] = {\n                    fixed4(.5, 0, .5, 1), // NO_ID
    (magenta)\n                    // ------------------- VALID MATERIALS BELOW\n                   
    {{ ALBEDO }}\n                };\n                return _ALBEDO[id + 1];\n           
    }\n\n            // -----------------------------------------------------------------------\n\n           
    void castRay(inout RayInfo3D ray, in float max_distance)\n            {\n               
    float d = ray.hit.distance;\n                Hit hit = {_MAX_DISTANCE, NO_ID};\n               
    ray.hit = hit;\n                for (ray.steps = 0; ray.steps < _MAX_STEPS; ray.steps++)\n               
    {\n                    if (d >= _MAX_DISTANCE || d >= max_distance)\n                       
    return;\n\n                    ray.p = ray.ro + d * ray.rd;\n\n                   
    Hit hit = __SDF(ray.p);\n                    if (hit.distance < _EPSILON_RAY)\n                   
    {\n                        ray.hit.distance = d;\n                        ray.hit.id
    = hit.id;\n                        return;\n                    }\n\n                   
    d += hit.distance;\n                }\n            }\n\n            // =======================================================================\n\n           
    fixed4 frag(v2f i, fixed facing : VFACE) : SV_TARGET0\n            {\n               
    const float3 screenPos = i.screenPos.xyz / i.screenPos.w; // 0,0 to 1,1 on screen\n\n               
    RayInfo3D ray = (RayInfo3D)0;\n\n                // NDC from (-1, -1, -1) to
    (1, 1, 1) \n                float3 NDC = 2. * screenPos.xyz - 1.;\n\n               
    float4 ro = mul(inv, float4(NDC.xy, UNITY_NEAR_CLIP_VALUE, 1)); // ray origin
    on near plane\n                ro /= ro.w;\n                #ifdef _RAYORIGIN_NEAR\n               
    #else\n                {\n                    float4 rs =\n                       
    #ifdef _ORIGIN_WORLD\n                        mul(UNITY_MATRIX_M, float4(i.hitpos,
    1));\n                        #else\n                        fixed4(i.hitpos,
    1);\n                    #endif\n                    ray.hit.distance = distance(mul(rs,
    SCALE_MATRIX), ro); // start on ray\n                }\n                #endif\n\n               
    float4 re = mul(inv, float4(NDC.xy, 1, 1)); // ray end on far plane\n               
    re /= re.w;\n                float3 rd = normalize((re - ro).xyz); // ray direction\n\n\n               
    ray.ro = ro; // in object space\n                ray.rd = rd; // in object space\n\n               
    ray.hit.distance += _RAY_ORIGIN_BIAS;\n\n                // read camera depth
    texture to correctly blend with scene geometry\n                // beware, that
    _CameraDepthTexture IS NOT the depth buffer!\n                // it is populated
    in the prepass and doesn't change in subsequent passes\n                // https://forum.unity.com/threads/does-depth-buffer-update-between-passes.620575/\n               
    float camDepth = CorrectDepth(tex2D(_CameraDepthTexture, screenPos.xy).rg);\n\n               
    float4 forward = mul(inv, float4(0, 0, 1, 1)); // ray end on far plane\n               
    forward /= forward.w;\n                forward = normalize(forward); // forward
    in object space\n\n                castRay(ray, camDepth / dot(forward, rd));\n\n\n               
    clip(ray.hit.id); // discard rays without hit\n\n                fixed4 color_material
    = __MATERIAL(ray.hit.id); // color\n\n                return color_material;\n           
    }\n\n            // =======================================================================\n           
    ENDHLSL\n        } // End Pass\n\n        // Pass {}\n    }\n}"
  includes: []
  requires:
  - SDF
  provides: []
